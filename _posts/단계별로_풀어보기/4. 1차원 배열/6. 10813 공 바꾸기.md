<div class="block_white">

## **설명**

<div class="block_angle_60">

### **입력**

- N, M : 100 이하의 정수

- (i, j)[] : M 줄에 걸쳐 들어오는 두 정수 (N 이하의 자연수)

</div>

<div class="block_angle_90">

### **상황**

- N 개의 상자에 1부터 N 까지의 정수가 적힌 공이 차례대로 들어가있다.

- i, j 가 들어오면 i 번째 상자와 j 번째 상자에 있는 공을 서로 바꾼다.

</div>

<div class="block_angle_120">

### **출력**

- 마지막에 상자에 들어있는 공들을 차례대로 출력한다.

</div>

</div> <!-- 설명 -->

<div class="block_grey">

## **소스 코드**

<div class="block_green">

### **Node**

``` js
const fs = require('fs')
const inputs = fs.readFileSync('/dev/stdin').toString().split('\n')

const [N, M] = inputs[0].split(' ').map(val => +val)

const resultArr = Array(N)
  .fill(0)
  .map((_, idx) => idx + 1)

for (let idx = 1; idx <= M; idx++) {
  const [i, j] = inputs[idx].split(' ').map(val => (+val) - 1)

  [resultArr[i], resultArr[j]] = [resultArr[j], resultArr[i]]
}

process.stdout.write(`${resultArr.join(' ')}`)
```

<br />

- #### **temp 변수 만들어서 값을 저장해도 된다.**

    + 하지만 그렇게 하면 이쁘지 않다.

- #### **저렇게 해도 실제 resultArr 값이 바뀐다.**

    + for 문 끝나면 [resultArr[i], resultArr[j]] 배열은 메모리에서 사라진다.

    + 하지만 resultArr[i] 와 resultArr[j] 값은 서로의 값이 잘 바뀐다.

- #### **대용량 입출력을 연습하기 위해 process.stdout.write 함수를 쓰는 습관을 들인다.**

</div>

<div class="block_blue">

### **Python**

``` python
import sys

input = sys.stdin.readline
output = sys.stdout.write

N, M = map(int, input().split())

resultArr = [i + 1 for i in range(N)]

for idx in range(M):
  i, j = map(int, input().split())
  resultArr[i - 1], resultArr[j - 1] = resultArr[j - 1], resultArr[i - 1]

output(f"{" ".join(str(x) for x in resultArr)}")
```

<br />

- #### **Python 역시 대량 입출력에 익숙해지기 위해 저 함수들을 쓴다.**

- #### **output 은 format 을 지정하여 커스터마이징이 용이하도록 한다.**

    + C 스타일의 잔재가 안쓴지 수년이 지나도 남아있다.

</div>

</div>