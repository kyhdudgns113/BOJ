<div class="block_white">

## **설명**

<div class="block_yellow">

### **입력**

- T: 입력받을 문자열 갯수 (1 <= T <= 10)

- S[]: 알파벳 대문자로만 이루어진 T개의 문자열. 길이 1,000 미만

</div>

<div class="block_green">

### **출력**

- 단어의 길이

</div>

</div> <!-- 설명 -->

<div class="block_grey">

## **소스 코드**

<div class="block_green">

### **Node**

``` js
const fs = require('fs')
const inputArr = fs.readFileSync('/dev/stdin').toString().split('\n')

const stringArr = inputArr.slice(1)

stringArr.forEach(str => {
  const len = str.length
  process.stdout.write(`${str.charAt(0)}${str.charAt(len - 1)}\n`)
})

```

<br />

<div class="block_white tp_80">

### **공통**

- #### 리눅스 환경에서 이상한 문자가 추가되어 문자열에 들어가는것을 방지하고자 trim 을 썼다.

- #### 대용량 입출력을 연습하기 위해 process.stdout.write 함수를 쓰는 습관을 들인다.

</div>

<div class="block_grey tp_80">

### **특이점**

- #### Node 로 풀 때 T 값을 사용하지 않을 수 있다.

- #### 물론 inputArr 의 인덱스를 1부터 T 까지 for 문을 돌 수도 있다.

</div>

</div> <!-- 소스 코드/ Node -->

<div class="block_blue">

### **Python**

``` python
import sys

input = sys.stdin.readline
output = sys.stdout.write

T = int(input())

while T > 0:
  string = list(input().strip())
  output(f"{string[0]}{string[-1]}\n")
  T -= 1
```

<br />

<div class="block_white tp_80">

### **공통**

- #### Python 역시 대량 입출력에 익숙해지기 위해 저 함수들을 쓴다.

- #### output 은 format 을 지정하여 커스터마이징이 용이하도록 한다.

</div>

<div class="block_grey tp_80">

### **특이점**

- #### string 을 배열(Python 의 list)로 변환하고 인덱싱을 했다.

</div>

</div> <!-- 소스 코드/ Python>

</div> <!-- 소스 코드 -->